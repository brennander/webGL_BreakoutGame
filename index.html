<!DOCTYPE html>
<html>
<head>

	<title>THREE.js Game Test</title>
	<script src="js/three.min.js"></script>
	<script src="js/THREEx.keyboardstate.js"></script>
	<script src="js/THREEx.windowresize.js"></script>
	<script src="http://code.jquery.com/jquery-latest.min.js"></script>

</head>
<body style='margin: 0px; background-color: #222222; overflow: hidden;'>
	<div align="center" style="color: white; font-family: helvetica">Press space to start!</div>
	<div align="center" style="color: red; font-family: helvetica"> Bounces : <span id="printHere"></span></div>
	<script type="text/javascript">
	//three.js setup
	var keyboard = new THREEx.KeyboardState();

	var WIDTH = window.innerWidth;
	var HEIGHT= window.innerHeight;

	var VIEW_ANGLE = 45,
		ASPECT = WIDTH / HEIGHT,
		NEAR = 0.1,
		FAR = 10000;

	var renderer = new THREE.WebGLRenderer();
	var camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );

	var scene = new THREE.Scene();

	scene.add(camera);

	camera.position.z = 1000;

	renderer.setSize(WIDTH, HEIGHT);
	renderer.setClearColor( 0x222222, 1 );

	document.body.appendChild( renderer.domElement );

	//declaring the rendering loop
	var onRenderFcts = [];

	var winResize = new THREEx.WindowResize(renderer, camera);

	//creating the player
	var playerMaterial = new THREE.MeshLambertMaterial( 
		{
			color: 0xffaa22,
			ambient: 0xffaa22,			
		});

	var playerWidth = 200;
	var playerHeight = 25;
	var playerDepth = 50;
	var player = new THREE.Mesh(
			new THREE.BoxGeometry(playerWidth, playerHeight, playerDepth),
			playerMaterial);
	
	scene.add(player);
	player.position.y = -250;
	player.position.z = 25;

	//creating the ball
	var ballRadius = 20;
	var ballQuality = 10;
	var ballMaterial = new THREE.MeshLambertMaterial ({
		color: 0x22ff22,
		ambient: 0x22ff22
	});
	var ball = new THREE.Mesh( new THREE.SphereGeometry(ballRadius, ballQuality, ballQuality), ballMaterial);
	scene.add(ball);
	ball.position.y = -200;
	ball.position.z = 25;

	//creating the play field
	var fieldMaterial = new THREE.MeshBasicMaterial ({
		color: 0x333333,
	});
	var fieldWidth = 1500;
	var fieldHeight = 800;
	var playField = new THREE.Mesh( new THREE.PlaneGeometry(fieldWidth, fieldHeight, fieldWidth / 100, fieldHeight / 100), fieldMaterial);
	scene.add(playField);
	playField.position.z = -25;
	playField.receiveShadows = true;

	//creating a row of bricks
	var bricks = [];
	var brickContainer = new THREE.Object3D();
	var brickRow = [];
	var brickHeight = 50;
	var brickWidth = 200;
	var brickDepth = 50;
	var rowHeight = 75;
	var rowWidth = 7;

	var brickMat = new THREE.MeshLambertMaterial( { 
		color: 0x2222ff,
		ambient: 0x0000ff,
	} );

	var brickGeo = new THREE.BoxGeometry(brickWidth, brickHeight, brickDepth);

	function addBrick(mat) {
			var brickMesh = new THREE.Mesh(brickGeo, mat);
			var brick = new THREE.Object3D();
			brick.add(brickMesh);
			bricks.push(brick);
		};

	function addBrickRow(rowNum) {
		var brickRowContainer = new THREE.Object3D();

		for (var s = 0; s < rowWidth; s++) {
			addBrick(brickMat);
			bricks[s].position.x = 220 * (s + 1);
			brickRow.push(bricks[s]);
		};

		brickRowContainer.add(brickRow);
		brickRowContainer.position.y = rowNum * rowHeight;
		brickRowContainer.position.z = 25;
		brickContainer.add(brickRowContainer);

	};

	function initBricks(rows) {
		for (var i = 1; i <= rows; i++) {
			addBrickRow(i);
		};
		
		brickContainer.position.y = (rows * rowHeight) + 400;
		brickContainer.position.x = -700;
		scene.add(brickContainer);
	};

	initBricks(3);

	//lighting
	var ambientLight = new THREE.AmbientLight ( 0x222222 );
	scene.add(ambientLight);
	var directionalLight = new THREE.DirectionalLight ( 0xffcc44, 1);
	directionalLight.position.set(0.5,1,0.5);
	scene.add(directionalLight);

	//controls
	onRenderFcts.push(function playerMovement (delta, now){
		var speed = 300;
		if (player.position.x + 100 >= fieldWidth / 2) {
			player.position.x -= 10;
		} else if (player.position.x - 100 <= -fieldWidth / 2) {
			player.position.x += 10;
		}
		if ( keyboard.pressed('left') ) {
			player.position.x -= speed * delta;
		}else if( keyboard.pressed('right')) {
			player.position.x += speed * delta;
		};
	});

	//ball movement
	var ballSpeed = 3;
	var ballDirX = 1;
	var ballDirY = 1;
	
	var playing = false;

	var score;
	var scoreDisplay;

	//player collision physics
	function playerCollision () {
		if (ball.position.x <= player.position.x + playerWidth/2 && ball.position.x >= player.position.x - playerWidth/2) {
			if (ball.position.y <= player.position.y + playerHeight/2 && ball.position.y >= player.position.y - playerHeight/2) {
				if (ballDirY < 0) {
					player.scale.x = 1.5;
					ballDirY = -ballDirY;
					scoreNum();
				};
			};
		};

		//lerp back to original scale
		player.scale.x += (1 - player.scale.x) * 0.2;
	};

	function scoreNum (){
		score += 1;
		scoreDisplay = score.toFixed(0);
		$('#printHere').html(scoreDisplay);
	};

	//play field ball collision
	function ballCollision () {
		
		if (ball.position.y + ballRadius >= fieldHeight / 2) {
			ballDirY = -ballDirY;
		};

		if (ball.position.y -ballRadius <= - fieldHeight / 2) {
			ballDirY = -ballDirY;
		};

		if (ball.position.x +ballRadius >= fieldWidth / 2) {
			ballDirX = -ballDirX;
		};

		if (ball.position.x -ballRadius <= -fieldWidth / 2) {
			ballDirX = -ballDirX;
		};
	};

	function init () {
		score = 0;
	};

	onRenderFcts.push(function ballPhysics (){
		
		//ball starts moving when space is pressed
		if (keyboard.pressed('space') && playing == false){
			playing = true;
			init(); 
		};

		if (playing) {
			ball.position.x += ballDirX * ballSpeed;
			ball.position.y += ballDirY * ballSpeed;
		};

		//limiting ball X-axis speeds to 2 * the set speed
		if (ballDirX > ballSpeed * 2) {
			ballDirX = ballSpeed * 2;
		} else if (ballDirX < -ballSpeed * 2) {
			ballDirX = -ballSpeed * 2
		};

		ballCollision();
		playerCollision();
	});

	

	//render loop

	onRenderFcts.push(function(){
		renderer.render(scene, camera);
	});

	var lastTimeMsec = null;
	requestAnimationFrame(function animate(nowMsec){
		requestAnimationFrame(animate);

		lastTimeMsec = lastTimeMsec || nowMsec-1000/60;
		var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
		lastTimeMsec = nowMsec;

		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000);
		});
	});

	</script>

</body>
</html>
