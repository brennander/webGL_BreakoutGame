<!DOCTYPE html>
<html>
<head>

	<title>THREE.js Game Test</title>
	<script src="js/three.min.js"></script>
	<script src="js/THREEx.keyboardstate.js"></script>
	<script src="js/THREEx.windowresize.js"></script>
	<script src="js/jquery-latest.min.js"></script>

</head>
<body style='margin: 0px; background-color: #222222; overflow: hidden;'>
	<div align="center" style="margin-top: 10px ; color: white; font-family: helvetica">Press space to start!</div>
	<div align="center" style="color: #22ff22; font-family: helvetica"> Bounces : <span id="printHere"></span></div>
	<script type="text/javascript">
	//three.js setup
	var keyboard = new THREEx.KeyboardState();

	var WIDTH = window.innerWidth;
	var HEIGHT= window.innerHeight - 85;

	var VIEW_ANGLE = 45,
		ASPECT = WIDTH / HEIGHT,
		NEAR = 0.1,
		FAR = 10000;

	var renderer = new THREE.WebGLRenderer();
	var camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );

	var scene = new THREE.Scene();

	scene.add(camera);

	camera.position.z = 1000;

	renderer.setSize(WIDTH, HEIGHT);
	renderer.setClearColor( 0x222222, 1 );

	document.body.appendChild( renderer.domElement );

	//declaring the rendering loop
	var onRenderFcts = [];

	var winResize = new THREEx.WindowResize(renderer, camera);

	//creating the player
	var playerMaterial = new THREE.MeshLambertMaterial( 
		{
			color: 0xffaa22,
			ambient: 0xffaa22,			
		});

	var playerWidth = 200;
	var playerHeight = 25;
	var playerDepth = 50;
	var player = new THREE.Mesh(
			new THREE.BoxGeometry(playerWidth, playerHeight, playerDepth),
			playerMaterial);
	
	scene.add(player);
	player.position.y = -250;
	player.position.z = 25;

	//creating the ball
	var ballRadius = 20;
	var ballQuality = 10;
	var ballMaterial = new THREE.MeshLambertMaterial ({
		color: 0x22ff22,
		ambient: 0x22ff22
	});
	var ball = new THREE.Mesh( new THREE.SphereGeometry(ballRadius, ballQuality, ballQuality), ballMaterial);
	scene.add(ball);
	ball.position.y = -200;
	ball.position.z = 25;

	//creating the play field
	var fieldMaterial = new THREE.MeshBasicMaterial ({
		color: 0x333333,
	});
	var fieldWidth = 1500;
	var fieldHeight = 800;
	var playField = new THREE.Mesh( new THREE.PlaneGeometry(fieldWidth, fieldHeight, fieldWidth / 100, fieldHeight / 100), fieldMaterial);
	scene.add(playField);
	playField.position.z = -25;
	playField.receiveShadows = true;

	//creating a row of bricks

	// TODO : Fix Brick Creation!!! //
	var bricks = [];
	var brickContainer = new THREE.Object3D();
	var brickRow = new THREE.Object3D();
	var brickHeight = 50;
	var brickWidth = 200;
	var brickDepth = 50;
	var rowHeight = 75;
	var s = 1;
	var rowWidth = 7;

	var brickMat = new THREE.MeshLambertMaterial( { 
		color: 0x2222ff,
		ambient: 0x0000ff,
	} );

	var brickGeo = new THREE.BoxGeometry(brickWidth, brickHeight, brickDepth);

	function addBrick(mat, i) {
			var brickMesh = new THREE.Mesh(brickGeo, mat);
			var brick = new THREE.Object3D();
			brick.add(brickMesh);
			bricks[i] = brick;

	}
	function addBrickRow(rowNum) {
		for (s; s <= rowWidth; s++) {
			addBrick(brickMat, s);
			bricks[s].position.x = 250 * s;
			brickRow.add(bricks[s]);
		}

		brickRow.position.y = rowNum * rowHeight
	}


	//lighting
	var ambientLight = new THREE.AmbientLight ( 0x222222 );
	scene.add(ambientLight);
	var directionalLight = new THREE.DirectionalLight ( 0xffcc44, 1);
	directionalLight.position.set(0.5,1,0.5);
	scene.add(directionalLight);

	//controls
	onRenderFcts.push(function playerMovement (delta, now){
		var speed = 300;
		if (player.position.x + 100 >= fieldWidth / 2) {
			player.position.x -= 10;
		} else if (player.position.x - 100 <= -fieldWidth / 2) {
			player.position.x += 10;
		}
		if ( keyboard.pressed('left') ) {
			player.position.x -= speed * delta;
		}else if( keyboard.pressed('right')) {
			player.position.x += speed * delta;
		};
	});

	//ball movement
	var ballSpeed = 3;
	var ballDirY = 1;
	var ballDirX = -1 + (Math.random() * 2) ;
	
	//Playing state
	var playing = false;

	//Score Display
	var score;
	var scoreDisplay;

	//player collision physics
	function playerCollision () {
		if (ball.position.x <= player.position.x + playerWidth/2 
			&& ball.position.x >= player.position.x - playerWidth/2) 
		{
			if (ball.position.y <= player.position.y + playerHeight/2 
				&& ball.position.y >= player.position.y - playerHeight/2) 
			{
				if (ballDirY < 0) {
					player.scale.x = 1.5;
					ballDirY = -ballDirY;
					impactDir();
					scoreNum();
				};
			};
		};

		//lerp back to original scale
		player.scale.x += (1 - player.scale.x) * 0.2;
	};

	
	//compare X position of ball and player, and change ballDirX accordingly

	function impactDir () {
		var ballIntersect_Relative;
		var ballIntersect_Normalised;
		
		var pX = player.position.x;
		var bX = ball.position.x;
		var maxBounce = 5 * ( Math.PI() / 12 );

		ballIntersect_Relative = (pX + 100) - bX;
		ballIntersect_Normalised = ballIntersect_Relative / 100;

		var bounceAngle = ballIntersect_Normalised * maxBounce;

		ballDirX = Math.cos(bounceAngle);
		ballDirY = -Math.sin(bounceAngle);

		/* if (bX > pX) {
			ballDirX = 1 * (pX / bX);
		} else if ( bX < pX) {
			ballDirX = -1 * (bX / pX);
		} else if (bX == pX) {
			ballDirX = 0;
		};/= */
	};

	//Score Display Update
	function scoreNum (){
		score += 1;
		scoreDisplay = score.toFixed(0);
		$('#printHere').html(scoreDisplay);
	};

	//play field ball collision
	function ballCollision () {
		
		if (ball.position.y + ballRadius >= fieldHeight / 2) {
			ballDirY = -ballDirY;
		};

		if (ball.position.y -ballRadius <= - fieldHeight / 2) {
			ballDirY = -ballDirY;
		};

		if (ball.position.x +ballRadius >= fieldWidth / 2) {
			ballDirX = -ballDirX;
		};

		if (ball.position.x -ballRadius <= -fieldWidth / 2) {
			ballDirX = -ballDirX;
		};
	};

	//Initalise game and set score to 0
	function init () {
		score = -1;
		scoreNum();
	};

	init();

	onRenderFcts.push(function ballPhysics (){
		
		//ball starts moving when space is pressed
		if (keyboard.pressed('space') && playing == false){
			playing = true;
			init(); 
		};

		if (playing) {
			ball.position.x += ballDirX * ballSpeed;
			ball.position.y += ballDirY * ballSpeed;
		};

		//limiting ball X-axis speeds to 2 * the set speed
		if (ballDirX > ballSpeed * 2) {
			ballDirX = ballSpeed * 2;
		} else if (ballDirX < -ballSpeed * 2) {
			ballDirX = -ballSpeed * 2
		};

		ballCollision();
		playerCollision();
	});

	//render loop

	onRenderFcts.push(function(){
		renderer.render(scene, camera);
	});

	var lastTimeMsec = null;
	requestAnimationFrame(function animate(nowMsec){
		requestAnimationFrame(animate);

		lastTimeMsec = lastTimeMsec || nowMsec-1000/60;
		var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
		lastTimeMsec = nowMsec;

		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000);
		});
	});

	</script>

</body>
</html>
